[
  {
    "objectID": "Spells.html",
    "href": "Spells.html",
    "title": "Session 2: Spells",
    "section": "",
    "text": "Well done on getting through the sorting stage, you should feel settled in now and ready to start learning some tidyverse spells. I also want to hard sell two messages:\n\nDon’t scroll down to the bottom of this script and go “No way, this looks really complicated - I’m out!”. Instead trust that it will make sense if I approach it one step at a time. I have to remind myself of this regularly and it applies just as much on day one as on day one thousand.\nThe examples in this script are all you need to get out there and start solving real world problems. Once you get to the end of this script, you will have built a house with a foundation. After that, it’s only wallpaper, flowerbeds and extensions from then on out.\n\n\n# Accio libraries\nlibrary(tidyverse)\nlibrary(here)\n\n# Accio data\nmovies &lt;- read.csv(file = here(\"materials\", \"data\", \"movies.csv\"))\ncharacters &lt;- read.csv(file = here(\"materials\", \"data\", \"Characters.csv\"))\nquidditch &lt;- read.csv(file = here(\"materials\", \"data\", \"quidditch.csv\"))\nquidditch_players &lt;- read.csv(file = here(\"materials\", \"data\", \"quidditch_players.csv\"))"
  },
  {
    "objectID": "Spells.html#introduction",
    "href": "Spells.html#introduction",
    "title": "Session 2: Spells",
    "section": "",
    "text": "Well done on getting through the sorting stage, you should feel settled in now and ready to start learning some tidyverse spells. I also want to hard sell two messages:\n\nDon’t scroll down to the bottom of this script and go “No way, this looks really complicated - I’m out!”. Instead trust that it will make sense if I approach it one step at a time. I have to remind myself of this regularly and it applies just as much on day one as on day one thousand.\nThe examples in this script are all you need to get out there and start solving real world problems. Once you get to the end of this script, you will have built a house with a foundation. After that, it’s only wallpaper, flowerbeds and extensions from then on out.\n\n\n# Accio libraries\nlibrary(tidyverse)\nlibrary(here)\n\n# Accio data\nmovies &lt;- read.csv(file = here(\"materials\", \"data\", \"movies.csv\"))\ncharacters &lt;- read.csv(file = here(\"materials\", \"data\", \"Characters.csv\"))\nquidditch &lt;- read.csv(file = here(\"materials\", \"data\", \"quidditch.csv\"))\nquidditch_players &lt;- read.csv(file = here(\"materials\", \"data\", \"quidditch_players.csv\"))"
  },
  {
    "objectID": "Spells.html#spells",
    "href": "Spells.html#spells",
    "title": "Session 2: Spells",
    "section": "Spells",
    "text": "Spells"
  },
  {
    "objectID": "Spells.html#section",
    "href": "Spells.html#section",
    "title": "Session 2: Spells",
    "section": "",
    "text": "OK let’s start learning some spells. I have chosen these ones as they are the ones I use almost daily. There are of course many more but you really can just figure out the rest as you go.\nReminder: we aren't asking our poor brains to remember where all the commas and squiggly lines are. Instead, we will try and remember, for example, that there exists a function within the tidyverse called rename, and trust that if we don’t remember where the commas and squiggly lines go, then we can just refresh our memories by looking it up on Google or by asking our favourite AI companion.\nThe rest of this demonstration will have the following simple structure: 8 categories of spell, and for each example there is also an example of how you might inspect/interrogate your output (Lumos!).\n\nSpell 1: Rename\nTip: whenever you see this “|&gt;” I want you to say “and then” in your head.\nOne of the great things about the tidyverse is that it is a very spoken way of writing code. Here I read the code below out in my head as:\nLet's create an object called movies_spell_1. movies_spell_1 is what you get after you to take the movies dataframe and then rename the columns with the periods in the name”.\nNote as well that you could have just called the new object “movies” i.e., overwriting the old one. Don’t think that you always have to create a new object every time, I’m just doing it here for demonstrative purposes.\n\nmovies_spell_1 &lt;- movies |&gt;\n  rename(\n    \"id\" = \"Movie.ID\",\n    \"title\" = \"Movie.Title\",\n    \"year\" = \"Release.Year\",\n    \"box_office\" = \"Box.Office\"\n  )\n\n# Lumos!\nnames(movies_spell_1)\n\n[1] \"id\"         \"title\"      \"year\"       \"Runtime\"    \"Budget\"    \n[6] \"box_office\"\n\n\nWhile i’m here, it looks a bit funky that some of the names are in small case and some have capitals. Let’s use rename again here to fix this (note with much larger data sets you might look for a more dynamic, i.e., less manual way of renaming these):\n\nmovies_spell_1 &lt;- movies_spell_1 |&gt;\n  rename(\n    \"runtime\" = \"Runtime\",\n    \"budget\" = \"Budget\"\n  )\n\n# Lumos!\nnames(movies_spell_1)\n\n[1] \"id\"         \"title\"      \"year\"       \"runtime\"    \"budget\"    \n[6] \"box_office\"\n\n\n\n\nSpell 2: Select\nNext we have select(). When you think select(), you think let's get some columns. I’ve shown a couple of examples of select() in action down below, but as with all of these spells, there is so much you can do with them, so if you run into a problem in R that is broadly to do with selecting columns, you can be confident that select() will have some role to play in the solution.\nSpoken translation:\n“Let's create a new thing called characters_spell_2_example_1. What characters_spell_2_example_1 is is what you get after you take the characters dataframe and then select only the Character.Name, Gender, and House columns”.\n\ncharacters_spell_2_example_1 &lt;- characters |&gt;\n  select(Character.Name, Gender, House)\n\n# Lumos!\nnames(characters_spell_2_example_1)\n\n[1] \"Character.Name\" \"Gender\"         \"House\"         \n\n\nNote that you can get the exact same results by using the column numbers:\n\ncharacters_spell_2_example_2 &lt;- characters |&gt;\n  select(2, 4:5)\n\n# Lumos!\nnames(characters_spell_2_example_2)\n\n[1] \"Character.Name\" \"Gender\"         \"House\"         \n\n\nHere is an example of using select() with another useful spell (function) inside it. There are lots of things that can be used within select(). Here you use starts_with() to select every column that starts with “Wand”. Other notable ones include ends_with() and contains().\n\ncharacters_spell_2_example_3 &lt;- characters |&gt;\n  select(starts_with(\"Wand\"))\n\n# Lumos!\nnames(characters_spell_2_example_3)\n\n[1] \"Wand..Wood.\" \"Wand..Core.\"\n\n\nA final useful thing to point out is that you don’t always need to reduce the number of columns when using Select, you can also use it to do a bit of tidying, here by re-ordering the columns.\nSpoken translation:\n“Let's create a new thing called movies_spell_2_example_4. What that thing is is what you get after taking the movies dataframe and then first selecting the Movie.Title column, then the Release.Year column and then just selecting everything else as it was before”.\n\nmovies_spell_2_example_4 &lt;- movies |&gt;\n  select(Movie.Title, Release.Year, everything())\n\n# Lumos!\nnames(movies_spell_2_example_4)\n\n[1] \"Movie.Title\"  \"Release.Year\" \"Movie.ID\"     \"Runtime\"      \"Budget\"      \n[6] \"Box.Office\"  \n\n\n\n\nSpell 3: Filter\nSo far so good? Remember, one step at a time. The next spell in our tidyverse spellbook is Filter(). All you need to remember is that where you have Select for columns, you have Filter for rows.\nSpoken translation:\n\"Let's create a thing called characters_spell_3_example_1. What that thing is is what you get after taking the characters dataframe and then filtering it to contain only rows in the House column that exactly equal the value \"Gryffindor“.\n\ncharacters_spell_3_example_1 &lt;- characters |&gt;\n  filter(House == \"Gryffindor\")\n\n# Lumos!\nhead(characters_spell_3_example_1 |&gt; select(House))\n\n       House\n1 Gryffindor\n2 Gryffindor\n3 Gryffindor\n4 Gryffindor\n5 Gryffindor\n6 Gryffindor\n\n\nSpoken translation:\n“Let's create a thing called characters_spell_3_example_2. That thing is what is created after taking the character dataframe and then filtering the rows so that the only rows left are those where the values in the Gender column are exactly equal to Female and the values in the Wand..Core. column are exactly equal to Dragon Heartstring”.\n\ncharacters_spell_3_example_2 &lt;- characters |&gt;\n  filter(Gender == \"Female\" & Wand..Core. == \"Dragon Heartstring\")\n\n# Lumos!\nhead(characters_spell_3_example_2 |&gt; select(Gender, Wand..Core.))\n\n  Gender        Wand..Core.\n1 Female Dragon Heartstring\n2 Female Dragon Heartstring\n3 Female Dragon Heartstring\n4 Female Dragon Heartstring\n\n\nFor this example coming up, we are going to create a useful object called a vector to help us write our next bit of code that uses filter. Think of this as being similar to creating a helper column in Excel. We know from watching the films that the cool houses are Gryffindor, Hufflepuff, and Ravenclaw, so let’s pop them in a vector for storage and call it cool_houses. The benefit of this is that whenever you want to refer to all of these at once, all we need to do is refer to cool_houses (imagine a vector with 500 names in it and you see why it becomes a more and more useful thing at scale).\nSpoken translation:\n“Let's create a thing called cool_houses. What cool_houses is is a vector containing the three names of the cool houses. Now that I have these ready to go, let's create a thing called characters_spell_3_example_3. What characters_spell_3_example_3 is what you get after taking characters and filtering the rows so that only rows in the House column that match the values in cool_houses remain”.\n\ncool_houses &lt;- c(\"Gryffindor\", \"Hufflepuff\", \"Ravenclaw\")\ncharacters_spell_3_example_3 &lt;- characters |&gt;\n  filter(House %in% cool_houses)\n\n# Lumos!\nunique(characters_spell_3_example_3$House)\n\n[1] \"Gryffindor\" \"Ravenclaw\"  \"Hufflepuff\"\n\n\nWe can also use Filter to look for things to exclude (as opposed to looking for things to include above with the cool_houses). Let’s follow on with that example and assign the value “Slytherin” to the object uncool_houses. From here we can use Filter with the != (“not equal to”) operator.\nSpoken translation:\n“Let's create a thing called uncool_houses. Let's assign the value, a string, Slytherin, to it. With this at our disposal, let's create a thing called characters_spell_3_example_4. characters_spell_3_example_4 is what you get by taking the characters dataframe and filtering so that only rows that don't equal the value assigned to uncool_houses remain”.\n\nuncool_houses &lt;- \"Slytherin\"\ncharacters_spell_3_example_4 &lt;- characters |&gt;\n  filter(House != uncool_houses)\n\n# Lumos!\nunique(characters_spell_3_example_4$House)\n\n[1] \"Gryffindor\"                   \"\"                            \n[3] \"Ravenclaw\"                    \"Hufflepuff\"                  \n[5] \"Beauxbatons Academy of Magic\" \"Durmstrang Institute\"        \n\n\n\n\nSpell 4: Mutate\nWhen you hear mutate I want you to think about creating a new column in Excel which uses the data from the other columns. In essence, you are just just creating new from old stuff with a formula in between to guide the process along.\nSpoken translation:\n“Let's create a thing called movies_spell_4_example_1, which is what you get after taking the movies dataframe and then creating a new column called profit. Each row in that column is what you get when you subtract the Budget value from the Box.Office value for that row”.\n\nmovies_spell_4_example_1 &lt;- movies |&gt;\n  mutate(profit = Box.Office - Budget)\n\n# Lumos!\nhead(movies_spell_4_example_1 |&gt; select(Budget, Box.Office, profit))\n\n     Budget Box.Office    profit\n1 125000000 1002000000 877000000\n2 100000000  880300000 780300000\n3 130000000  796700000 666700000\n4 150000000  896400000 746400000\n5 150000000  942000000 792000000\n6 250000000  943200000 693200000\n\n\n\nMutate with case_when\nSimilarly to all of the other tidyverse spells, there’s a lot of things you can do within mutate(). Just knowing of and remembering that mutate() exists and it creates new columns is half the battle - that’s your ticket to finding the resources you need whilst solving problems on the go because you can use it in searches for better results. Here’s one very common example though that will come up a fair bit - using mutate() alongside case_when(). Just think of creating a new column in Excel and using an if-else of if-else-if-else etc to fill it.\nSpoken translation:\n“Let's store all of the main characters in vector called main_characters so that I can refer to it easily. Let's then create an object called characters_spell_4_example_2. characters_spell_4_example_2 is what you get by taking the characters dataframe and then creating a new column called main_character_yn. To create main_character_yn, let's go through each row and if that row has a value that's in our main_characters vector, let's fill that row with y. For anything else that could possibly ever come up, let's call that n”.\n\nmain_characters &lt;- c(\n  \"Harry Potter\", \"Ron Weasley\", \"Hermione Granger\",\n  \"Albus Dumbledore\", \"Severus Snape\", \"Voldemort\"\n)\n\ncharacters_spell_4_example_2 &lt;- characters |&gt;\n  mutate(main_character_yn = case_when(\n    Character.Name %in% main_characters ~ \"y\",\n    TRUE ~ \"n\"\n  ))\n\n# Lumos!\ntable(characters_spell_4_example_2$main_character_yn)\n\n\n  n   y \n160   6 \n\n\n\n\n\nSpell 5: Pivot\nThis will make sense to you if you have used pivot tables in Excel or Google Sheets. All you need to know is:\n\nYou can arrange your data long or wide.\nJust like pivot tables in Excel.\nLong format by default is probably the tidiest, but you don’t need to think about this much unless the problem dictates it. A common example is data visualisation packages or tools needing the data to be in a specific format to work.\n\n\nPivot_longer\nSpoken translation:\n“Let's create a new object called quidditch_spell_5_example_1. This new object is what you get after taking the quidditch dataframe and then converting the four house columns from wide format to long format. Let's present the information on which house the points refer to in a column called house, and let's pop all of the values, i.e., quidditch points scored into a column called points”.\n\nquidditch_spell_5_example_1 &lt;- quidditch |&gt;\n  pivot_longer(\n    cols = gryffindor:slytherin,\n    names_to = \"house\",\n    values_to = \"points\"\n  )\n\n# Lumos!\nhead(quidditch_spell_5_example_1, n = 10)\n\n# A tibble: 10 × 6\n      id Movie.ID month top_scorer     house      points\n   &lt;int&gt;    &lt;int&gt; &lt;chr&gt; &lt;chr&gt;          &lt;chr&gt;       &lt;int&gt;\n 1     1        1 jan   Harry Potter   gryffindor    100\n 2     1        1 jan   Harry Potter   hufflepuff     70\n 3     1        1 jan   Harry Potter   ravenclaw     100\n 4     1        1 jan   Harry Potter   slytherin      20\n 5     2        1 feb   Cedric Diggory gryffindor    100\n 6     2        1 feb   Cedric Diggory hufflepuff    100\n 7     2        1 feb   Cedric Diggory ravenclaw     120\n 8     2        1 feb   Cedric Diggory slytherin      60\n 9     3        1 mar   Oliver Wood    gryffindor    100\n10     3        1 mar   Oliver Wood    hufflepuff     20\n\n\n\n\nPivot_wider\nSpoken translation:\n“Let's create an object called quidditch_spell_5_example_2. This new object quidditch_spell_5_example_2 is what you get after you take quidditch_spell_5_example_1 and then pivot the house column wider. This means that all of the unique values in that column, the four houses, will have their own column. The values in that column will come from the points column”.\n\nquidditch_spell_5_example_2 &lt;- quidditch_spell_5_example_1 |&gt;\n  pivot_wider(names_from = house, values_from = points)\n\n# Lumos!\nhead(quidditch_spell_5_example_2, n = 10)\n\n# A tibble: 10 × 8\n      id Movie.ID month top_scorer     gryffindor hufflepuff ravenclaw slytherin\n   &lt;int&gt;    &lt;int&gt; &lt;chr&gt; &lt;chr&gt;               &lt;int&gt;      &lt;int&gt;     &lt;int&gt;     &lt;int&gt;\n 1     1        1 jan   Harry Potter          100         70       100        20\n 2     2        1 feb   Cedric Diggory        100        100       120        60\n 3     3        1 mar   Oliver Wood           100         20       110       120\n 4     4        1 apr   Walburga Black         60         40       140        60\n 5     5        1 may   Oliver Wood            90        130        50        60\n 6     6        1 jun   Seamus Finnig…          0        150        20        60\n 7     7        1 jul   Draco Malfoy          120         30       100        70\n 8     8        1 aug   Fred Weasley           90        140        90        90\n 9     9        1 sep   Oliver Wood            80         20        10       110\n10    10        1 oct   Pomona Sprout          50         20       130        80\n\n\n\n\n\nSpell 6: Join\nIf you have worked with databases before you will know the principle of joining very well. If you have used VLOOKUP and its many off-shots in Excel you will also have a good idea. We use joins when you have two sources of data and we want to use the content of one to expand upon the other. This usually means having one smaller lookup table and one larger main data set. In the example below we have two sources of data.\n\nquidditch_players: a small list of characters and a yn indicator of whether or not they are quidditch players or not.\ncharacters: a much larger data set with information on all of the characters.\n\nWouldn’t it be cool if we could make our character dataframe even more informative by also including whether or not a given character is a quidditch player? Well all we need to do that is some common source of information between the two data sources and we are ready to rock!\nSince both sources of data contain the character names in a column we can use this information to join them together. It’s worth noting that there are several different types of joins that exist, but I almost never use them. For some reason I almost always use left joins, as in the example below.\nHere’s the lookup table:\n\n# Lumos!\nhead(quidditch_players)\n\n    Character.Name quidditch_player\n1     Harry Potter                y\n2   Cedric Diggory                y\n3 Hermoine Granger                n\n4      Oliver Wood                y\n5    Percy Weasley                n\n6   Walburga Black                n\n\n\nAnd here’s the left join. Spoken translation:\n“Let's create an object called characters_spell_6_example_1. This new object is what you get after you take the characters dataframe and join the quidditch_players dataframe to it. This in practice means creating a new column in the characters dataframe called quidditch_player as that is the only other column in the lookup table. As such, use the Character.Name column to join them as they both have this in common, and wherever a row in the Character.Name column in the characters dataframe matches a row in the quidditch_players lookup, fill the value in the quidditch_player column with whatever is in the lookup table. If there isn't a match, just return NA”.\n\ncharacters_spell_6_example_1 &lt;- characters |&gt;\n  left_join(quidditch_players, by = \"Character.Name\")\n\n# Lumos!\nhead(characters_spell_6_example_1 |&gt;\n  select(Character.Name, quidditch_player) |&gt;\n  filter(!is.na(quidditch_player)), n = 10)\n\n    Character.Name quidditch_player\n1     Harry Potter                y\n2     Draco Malfoy                y\n3     Fred Weasley                y\n4    Ginny Weasley                y\n5    Luna Lovegood                n\n6  Seamus Finnigan                y\n7   Cedric Diggory                y\n8    Percy Weasley                n\n9      Oliver Wood                y\n10  Lavender Brown                y\n\n\n\n\nSpell 7: Piping\nJust like Dumbledore in the Deathly Hallows Part Two, I’ve been with-holding information from you all along (I’m sorry if these metaphors are too much but i’m really enjoying them). What I’ve been holding back is that sword of Gryffindor reveals itself not to anyone who needs it, but instead to anyone that presses “shift + \\ + &gt;”. This shortcut reveals the sword of Gryffindor, otherwise known as the native R pipe |&gt;. Remember I asked you to say “and then” in your head every time you seen it? Well you were subconsciously training yourself to call the sword all along. You can call on the sword to chain together as many other tidyverse spells as you want in one bit of code, unlocking the true power of the tidyverse.\nSpoken translation:\n“Let's create an object called characters_spell_7_example_1. This new object is what is created when you take the characters dataframe AND THEN filter the rows so that no rows where Species is Human or Species is a blank cell remain AND THEN create a new column called character_morals. To fill the rows of character_morals, go row-by-row and if the value for Character.Name is one of Kreacher, Fenrir Greyback, or Bogrod, then fill the value is 'baddie'. IF the value for Character.Name is one of Griphook, Aragog, or Bane, then the value is 'its_complicated'. For everything and anything else that could possibly come up, then the value is 'goodie'....AND THEN keep only columns in my new object that contain the string \"character\", irrespective or case”.\n\ncharacters_spell_7_example_1 &lt;- characters |&gt; # AND THEN\n  filter(Species != \"Human\" & Species != \"\") |&gt; # AND THEN\n  mutate(character_morals = case_when(\n    Character.Name %in% c(\"Kreacher\", \"Fenrir Greyback\", \"Bogrod\") ~ \"baddie\",\n    Character.Name %in% c(\"Griphook\", \"Aragog\", \"Bane\") ~ \"its_complicated\",\n    TRUE ~ \"goodie\"\n  )) |&gt; # AND THEN\n  select(contains(\"character\"))\n\n# Lumos!\nhead(characters_spell_7_example_1, n = 10)\n\n   Character.ID       Character.Name character_morals\n1             5        Rubeus Hagrid           goodie\n2            11          Remus Lupin           goodie\n3            27                Dobby           goodie\n4            30             Griphook  its_complicated\n5            39       Moaning Myrtle           goodie\n6            47 Nearly Headless Nick           goodie\n7            48             Kreacher           baddie\n8            54     Helena Ravenclaw           goodie\n9            59      Filius Flitwick           goodie\n10           64               Bogrod           baddie\n\n\n\n\nSpell 8: Summarise\nAlmost there! Imagine you are in an Excel workbook and you are wanting to generate descriptive statistics, means, medians, percentages, counts, and so on and so forth. In the tidyverse, you can do all of that under the summarise() umbrella. This is useful in two ways:\n\nIt fits nicely in with all your other tidyverse code.\nIt gives you an anchor to start any Googling or prompting you need to do to find whatever variation you need for a given problem.\n\nSpoken translation:\n“Let's create an object called movies_spell_8_example_1. This new object is what you get after taking the movies dataframe and calculating the mean and the median of the Box.Office column. When calculating these, if any NAs pop up, let's just ignore them”.\n\nmovies_spell_8_example_1 &lt;- movies |&gt;\n  summarise(\n    mean_box_office = mean(Box.Office, na.rm = TRUE),\n    median_box_office = median(Box.Office, na.rm = TRUE)\n  )\n\n# Lumos!\nprint(movies_spell_8_example_1)\n\n  mean_box_office median_box_office\n1       972437500         942600000\n\n\nI’m adding this one just to show that you can do lots of funky stuff within summarise(), to hammer home that you routinely start off with summarise() and then have a bit of faith that the solution will more often that not exist within it.\nSpoken translation:\n“Let's create an object called movies_spell_8_example_2. This is what you get after taking the movies dataframe and then calculating the percentage of films that meet the definition of being long (i.e., has  Runtime greater than 140 minutes). In order to calculate that let's create a vector of values, one for every row in Runtime, with a 1 being assigned to the row if Runtime &gt; 140 and a 0 if not. After that, let's average the 1 and 0s in this vector and ignore any NAs as we go. And finally, let's multiply this by 100 so as to make it a percentage”.\n\nmovies_spell_8_example_2 &lt;- movies |&gt;\n  # Let's call a \"long\" film one that is over 140 mins\n  summarise(percentage_long = mean(Runtime &gt; 140, na.rm = TRUE) * 100)\n\n# Lumos!\nprint(movies_spell_8_example_2)\n\n  percentage_long\n1              75\n\n\nA very common function to use alongside summarise is group_by. Here we get to point all of that work that summarise does for us to any number of groups that we specify in the group_by() expression. I’ve also added a couple of extra lines at the end to tidy up the results.\nSpoken translation:\n“Let's create an object called quidditch_spell_8_example_3. This new object is what you get when you take the quidditch dataframe AND THEN create a new column called total_score. total_score is filled by adding the points for all four houses for a given row...AND THEN we are going to get ready for averaging by first grouping our data by Movie.ID so that we can get an average of each...AND THEN let's go ahead and find the mean total score for each film, ignoring any NAs as we go along....AND THEN after we have our results let's round the values in any numeric column we come across to 0 decimal places AND THEN let's finish up by sorting these values from largest to smallest so that we can easily see which films have the highest average quidditch scores”.\n\nquidditch_spell_8_example_3 &lt;- quidditch |&gt;\n  mutate(total_score = gryffindor + hufflepuff + ravenclaw + slytherin) |&gt;\n  group_by(Movie.ID) |&gt;\n  summarise(mean_total_score = mean(total_score, na.rm = TRUE)) |&gt;\n  mutate_if(is.numeric, round, 0) |&gt;\n  arrange(desc(mean_total_score))\n\n# Lumos!\nprint(quidditch_spell_8_example_3)\n\n# A tibble: 8 × 2\n  Movie.ID mean_total_score\n     &lt;dbl&gt;            &lt;dbl&gt;\n1        2              342\n2        4              324\n3        8              304\n4        7              299\n5        1              295\n6        6              293\n7        3              280\n8        5              276\n\n\n\n\nRecap\n\n\nA forest is too big to worry about, let’s focus on the tree in front of us instead.\nLet’s not become fixated on commas and squiggly lines, let’s instead learn the tidyverse framework and use this knowledge to find the resources we need when we need them.\nThe first two sessions have everything they need in them to start solving real problems in R."
  },
  {
    "objectID": "index.html#section",
    "href": "index.html#section",
    "title": "Home",
    "section": "",
    "text": "Three sessions designed to build the foundations of an enjoyable and efficient experience analysing and transforming data in R.\nInitially created to mentor and support my colleagues at City and Guilds Coffee and Code club.\nUses data and example centred around the theme of the Harry Potter films and books, with data either synthesised or sourced from Kaggle."
  },
  {
    "objectID": "index.html#sections",
    "href": "index.html#sections",
    "title": "Home",
    "section": "Sections",
    "text": "Sections\n\nSession 1 is called “Sorting” and focuses on justification for coding, coding in R, and getting set up to start working with data.\nSession 2 is called “Spells” and equips the reader with a spellbook full of tidyverse staple functions.\nSession 3 is called “Defence Against the Dark Arts” as it grapples with more advanced concepts for those looking to scale up and automate their coding."
  },
  {
    "objectID": "index.html#contributions",
    "href": "index.html#contributions",
    "title": "Home",
    "section": "Contributions",
    "text": "Contributions\n\nIf the materials could be improved, or i’ve made a mistake, just let me know via pull request or informal chat."
  },
  {
    "objectID": "index.html#disclaimer",
    "href": "index.html#disclaimer",
    "title": "Home",
    "section": "Disclaimer",
    "text": "Disclaimer\n\nSeveral witches and wizards were harmed in the creation of these materials."
  },
  {
    "objectID": "index.html#github",
    "href": "index.html#github",
    "title": "Home",
    "section": "Github",
    "text": "Github\nhttps://github.com/tomh1988-8/harry_potteR"
  },
  {
    "objectID": "Defence_Against_the_Dark_Arts.html",
    "href": "Defence_Against_the_Dark_Arts.html",
    "title": "Session 3: Defence Against the Dark Arts",
    "section": "",
    "text": "Word has gotten out that you are a confident coder now. With that, the data requests made of you have grown more serious, darker. We must prepare ourselves. We must learn Defence Against the Dark Arts - ways to scale up our code so that we can efficiently manage larger or more complicated tasks. In this section we are going to learn these techniques by simulating a deadly magical battle, much like the final battle in the Deathly Hallows. In order to survive we will need to acquaint ourselves with conditional logic, functions, and loops.\nIf you’ll allow a quick aside from the dark arts metaphor - a positive spin on this next step is that you are in a place where you are getting grander and more exciting ideas about how to approach analysing data and building data products. With a little bit of upfront investment in some new techniques, this process can be fun and the results more reliable, reproducible, and accessible to others, so let’s begin!\n\n# Accio libraries\nlibrary(tidyverse)\nlibrary(here)\nlibrary(glue)\nlibrary(openxlsx)\n\n# Accio data\nspells &lt;- read.csv(file = here(\"materials\", \"data\", \"spells.csv\"))\ncharacters &lt;- read.csv(file = here(\"materials\", \"data\", \"Characters.csv\"))\n\n\n\nA compulsory reminder which is relevant now more than ever is to not worry about the commas and squiggly lines, focus instead on the gist - the basic principles of what we are setting out to do and why. If you have these, then you can always seek out one of many available resources online to fill in the gaps if and when needed.\nThink of an =IF() or an =IFELSE() in Excel. The basic idea that we carry out an operation based on a condition is one of the most fundamental and powerful principles in programming. In Excel, however, it becomes quite laborious quite quickly to extend the logic within an =IF() statement to accomodate more complicated tasks and the formula quickly becomes unmanageable. This is a lot more manageable in R and after you wrap your head around it you can achieve spectacularly complex feats of data manipulation and transformation.\nThe following examples relies on data sets - one on Harry Potter characters, and the other one spells. Check them out below:\n\nstr(characters)\n\n'data.frame':   166 obs. of  9 variables:\n $ Character.ID  : int  1 2 3 4 5 6 7 8 9 10 ...\n $ Character.Name: chr  \"Harry Potter\" \"Ron Weasley\" \"Hermione Granger\" \"Albus Dumbledore\" ...\n $ Species       : chr  \"Human\" \"Human\" \"Human\" \"Human\" ...\n $ Gender        : chr  \"Male\" \"Male\" \"Female\" \"Male\" ...\n $ House         : chr  \"Gryffindor\" \"Gryffindor\" \"Gryffindor\" \"Gryffindor\" ...\n $ Patronus      : chr  \"Stag\" \"Jack Russell Terrier\" \"Otter\" \"Phoenix\" ...\n $ Wand..Wood.   : chr  \"Holly\" \"\" \"Vine\" \"Elder\" ...\n $ Wand..Core.   : chr  \"Phoenix Feather\" \"\" \"Dragon Heartstring\" \"Thestral Tail Hair\" ...\n $ student       : chr  \"y\" \"y\" \"y\" \"n\" ...\n\n\n\nstr(spells)\n\n'data.frame':   61 obs. of  5 variables:\n $ Spell.ID   : int  1 2 3 4 5 6 7 8 9 10 ...\n $ Incantation: chr  \"Accio\" \"Aguamenti\" \"Alarte Ascendare\" \"Alohomora\" ...\n $ Spell.Name : chr  \"Summoning Charm\" \"Water-Making Spell\" \"Launch an object up into the air\" \"Unlocking Charm\" ...\n $ Effect     : chr  \"Summons an object\" \"Conjures water\" \"Rockets target upward\" \"Unlocks target\" ...\n $ Light      : chr  \"\" \"Icy blue\" \"Red\" \"Blue\" ...\n\n\nThese simple dataframes (alongside having seen the films!) are perfect for practicing some conditional logic. Let’s write some code to print out the name and effect of any spell in spells. However, Hermoine is around and if we mispronounce her favourite spell or try and cast a nonsense spell, she’s going to call us out on it. Use the helper code to get the unique values of spells in the spells dataframe and try some different spells!\nSpoken translation:\n“Let's save the spell we want to apply some conditional logic too in an object called spell_cast. If the spell cast is exactly equal to Wingardium Leviosa, then print out some guidance on how to properly pronounce the spell. Apart from that exception, if the spell exists in the Incantation column of the spells dataframe then print out the spell name and the effect from the Effect column. If anything else is input other than that already accounted for print out that it is not a spell.”\n\n# unique(spells$Incantation)\n\nspell_cast &lt;- \"Immobulus\" # Change this to test different spells\n\n# Check if the spell is valid\nif (spell_cast == \"Wingardium Leviosa\") {\n  print(\"It's leviOsa, not levioSA!\")\n} else if (spell_cast %in% spells$Incantation) {\n  spell_info &lt;- spells |&gt; filter(Incantation == spell_cast)\n  print(glue(\"Spell: {spell_info$Incantation}, Effect: {spell_info$Effect}\"))\n} else {\n  print(\"Not a spell, try again.\")\n}\n\nSpell: Immobulus, Effect: Stops movement and actions of the target\n\n\n\n\n\nMy guess is that you will noticed two things after having tried out a few spells. The first is that achieving a different output by only changing one value feels very powerful. The second is that having to run all that code every time a new spell is cast gets clunky and painful. Imagine you wanted to try out 100 spells in the same script? The code would get out of hand very quickly and the resulting script would be very messy, manual, and repetitive.\nThat’s why we have functions - we wrap code that we want to run again and again with slightly different inputs into functions. The result of this is that we can stash away the code somewhere safe and out of the way and reap their benefits with very little code, typically just one line. A whole world of possibilities opens up when you start writing functions, the most immediate of which are that your code can be scaled up, shared, and tested much more effectively.\nHere is the some code as the example above wrapped in a function called spell_practice. This function takes one argument called spell_cast which allows the user to cast a spell with great ease. We say “wrapped” in a function, because all we did was take our existing code and wrap it with this:\n\nspell_practice &lt;- function(spell_cast) {\n  \n  # insert magical code here\n  \n}\n\n\n# unique(spells$Incantation)\nspell_practice &lt;- function(spell_cast) {\n  if (spell_cast == \"Wingardium Leviosa\") {\n    print(\"It's leviOsa, not levioSA!\")\n  } else if (spell_cast %in% spells$Incantation) {\n    spell_info &lt;- spells |&gt; filter(Incantation == spell_cast)\n    print(glue(\"Spell: {spell_info$Incantation}, Effect: {spell_info$Effect}\"))\n  } else {\n    print(\"Not a spell, try again.\")\n  }\n}\n\nAnd now look how easy it is to cast a spell:\n\n# unique(spells$Incantation)\nspell_practice(spell_cast = \"Expelliarmus\")\n\nSpell: Expelliarmus, Effect: Disarms an opponent\n\n\n\n# unique(spells$Incantation)\nspell_practice(spell_cast = \"Wingardium Leviosa\")\n\n[1] \"It's leviOsa, not levioSA!\"\n\n\nLet’s step it up a bit and re-enact a full magical battle. Rather than obsess over the actual contents of the battle_simulator function below, I want to try and sell to you how much time and effort was saved and how much more readable the code is now that I don’t have to copy and paste and change the code slightly to accomodate all of the multiple variations of it I might want to run. Being able to call it in only one line also makes it practical to use my function in more ambitious ways, which we’ll look at below.\nSpoken translation:\n“Let's write a magic battle simulation function with the following rules:\n1. If you cast Hermoine's favourite spell, she will correct your pronunciation.\n2. If you cast an unforgiveable spell and are a Hogwart's student you will be expelled and this will be your House status in the characters dataframe.\n3. If you cast a killing spell the character it was cast on will become a ghost in the characters dataframe.\n4. If you try and kill Harry with a spell it will not work because he is the boy who lived.\n5. The modified characters dataframe will be returned to you to ensure that the battle was carried out fairly”\n\n# unique(spells$Incantation)\n# unique(characters$Character.Name)\n\nbattle_simulator &lt;- function(character_name, spell_cast, spell_cast_to) {\n  # Unforgivable curses\n  unforgivable_curses &lt;- c(\"Avada Kedavra\", \"Crucio\", \"Imperio\")\n\n  # Initialize characters_conditionals_example_1 to the original characters dataset\n  characters_conditionals_example_1 &lt;- characters\n  modified &lt;- FALSE\n\n  # Check if the spell is valid\n  if (spell_cast == \"Wingardium Leviosa\") {\n    print(\"It's leviOsa, not levioSA!\")\n  } else if (spell_cast %in% unforgivable_curses) {\n    # If the spell is unforgivable, expel the character\n    characters_conditionals_example_1 &lt;- characters_conditionals_example_1 %&gt;%\n      mutate(House = if_else(\n        Character.Name == character_name &\n          student == \"y\" &\n          House %in% c(\"Gryffindor\", \"Slytherin\", \"Hufflepuff\", \"Ravenclaw\"),\n        \"expelled from hogwarts\",\n        House\n      ))\n\n    if (characters_conditionals_example_1 %&gt;% filter(Character.Name == character_name, student == \"y\") %&gt;% nrow() &gt; 0) {\n      print(glue(\"{character_name} has been expelled from Hogwarts for casting {spell_cast}!\"))\n      modified &lt;- TRUE\n    } else {\n      print(glue(\"{character_name} cast {spell_cast}, not cool bro.\"))\n    }\n\n    # Special case for Avada Kedavra\n    if (spell_cast == \"Avada Kedavra\") {\n      characters_conditionals_example_1 &lt;- characters_conditionals_example_1 %&gt;%\n        mutate(Species = if_else(\n          Character.Name == spell_cast_to & Character.Name != \"Harry Potter\",\n          \"ghost\",\n          Species\n        ))\n\n      if (spell_cast_to == \"Harry Potter\") {\n        print(\"But Harry Potter survived because he is the boy who lived!\")\n      } else {\n        print(glue(\"{spell_cast_to} has been turned into a ghost by {character_name}!\"))\n      }\n      modified &lt;- TRUE\n    }\n  } else if (spell_cast %in% spells$Incantation) {\n    spell_info &lt;- spells %&gt;% filter(Incantation == spell_cast)\n    print(glue(\"Spell: {spell_info$Incantation}, Effect: {spell_info$Effect}\"))\n  } else {\n    print(\"Not a spell, try again.\")\n  }\n\n  # Return the modified dataframe if changes were made, otherwise return the original characters dataframe\n  if (modified) {\n    return(characters_conditionals_example_1)\n  } else {\n    return(characters)\n  }\n}\n\n\nex1_generic &lt;- battle_simulator(\"Hermione Granger\", \"Oculus Reparo\", \"Harry Potter\")\n\nSpell: Oculus Reparo, Effect: Repairs glasses\n\n\n\nex2_wl &lt;- battle_simulator(\"Ron Weasley\", \"Wingardium Leviosa\", \"Hermione Granger\")\n\n[1] \"It's leviOsa, not levioSA!\"\n\n\n\nex3_unforgiveable_adult &lt;- battle_simulator(\"Lucius Malfoy\", \"Crucio\", \"Dobby\")\n\nLucius Malfoy cast Crucio, not cool bro.\n\n\n\nex4_unforgiveable_student &lt;- battle_simulator(\"Draco Malfoy\", \"Imperio\", \"Neville Longbottom\")\n\nDraco Malfoy has been expelled from Hogwarts for casting Imperio!\n\n\n\nex5_ghost &lt;- battle_simulator(\"Bellatrix Lestrange\", \"Avada Kedavra\", \"Sirius Black\")\n\nBellatrix Lestrange cast Avada Kedavra, not cool bro.\nSirius Black has been turned into a ghost by Bellatrix Lestrange!\n\n\n\nex6_boy_who_lived &lt;- battle_simulator(\"Voldemort\", \"Avada Kedavra\", \"Harry Potter\")\n\nVoldemort cast Avada Kedavra, not cool bro.\n[1] \"But Harry Potter survived because he is the boy who lived!\"\n\n\n\n\n\nI hope you enjoyed casting some spells and testing out some of the variations within the battle_simulator function. Why don’t you customise it, e.g., by stipulating that muggles can’t cast spells? Customising the code of others is a great way to get to grips with it and to optimise it for our individual needs.\nBut what if we had a function or set of functions that we wanted to run on an industrial scale? Even those one-liners above would get old fast if we wanted to run e.g., 1000 variations. Looping is one technique that can help here. There are some modern R-specific solutions here to simplify loops [see this article if interested](https://www.r-bloggers.com/2021/05/apply-family-in-r-apply-lapply-sapply-mapply-and-tapply/). These modern takes reduce code, but I would argue that they do so at the expense of being readable as they grow in complexity - in short the code doesn’t look like how we think about the processes they represent (in my very humble opinion). So my pitch is for good old loops, the most common of which is the for loop, which i’ll demonstrate below.\nThe core of the idea is that we have some set of entities, be it a list of string, or set of columns of rows in a dataframe, and we want to go through each iteration of that set and carry out an operation on it. Think “for each iteration of…do x”. The “i” that you will often see is a conventional placeholder. To test this, swap out each i for banana and watch the code still work). With that in mind lets simulate a battle from the Deathly Hallows (more or less) by casting lots of spells at once. To do that we need to store all of our intended steps in something. Here we are creating an object with the intention of looping through its contents, but often you won’t need to do that as your target will already exist.\n\n# Create a readable table of battles using tribble\nbattles &lt;- tribble(\n  ~caster, ~spell, ~target,\n  \"Voldemort\", \"Avada Kedavra\", \"Mad-Eye Moody\",\n  \"Fenrir Greyback\", \"Avada Kedavra\", \"Remus Lupin\",\n  \"Voldemort\", \"Avada Kedavra\", \"Garrick Ollivander\",\n  \"Molly Weasley\", \"Avada Kedavra\", \"Bellatrix Lestrange\",\n  \"Voldemort\", \"Avada Kedavra\", \"Fred Weasley\",\n  \"Voldemort\", \"Avada Kedavra\", \"Harry Potter\"\n)\n\n\n# Lumos!\nhead(battles)\n\n# A tibble: 6 × 3\n  caster          spell         target             \n  &lt;chr&gt;           &lt;chr&gt;         &lt;chr&gt;              \n1 Voldemort       Avada Kedavra Mad-Eye Moody      \n2 Fenrir Greyback Avada Kedavra Remus Lupin        \n3 Voldemort       Avada Kedavra Garrick Ollivander \n4 Molly Weasley   Avada Kedavra Bellatrix Lestrange\n5 Voldemort       Avada Kedavra Fred Weasley       \n6 Voldemort       Avada Kedavra Harry Potter       \n\n\nSpoken translation:\n“My battle_simulator function returns a dataframe, so if I'm going to run it lots at once, I'm going to need something to store them in, so let's create an empty list ahead of time before we begin. Ok let's begin. For every row in the battles dataframe, first create an name for the dataframe the battle_simulator function is about to produce. Then update my empty list with the product of my battle_simuilator function. In order to run the battle_simulator function look to the caster column to get the  character_name argument, the spell column to get the spell_cast argument, and the target column to get the spell_cast_to argument.”\n\n# Loop through battles and store results in a list\nbattle_results &lt;- list()\n\nfor (i in 1:nrow(battles)) {\n  battle_name &lt;- paste0(\"battle_\", i)\n  battle_results[[battle_name]] &lt;- battle_simulator(battles$caster[i], battles$spell[i], battles$target[i])\n}\n\nVoldemort cast Avada Kedavra, not cool bro.\nMad-Eye Moody has been turned into a ghost by Voldemort!\nFenrir Greyback cast Avada Kedavra, not cool bro.\nRemus Lupin has been turned into a ghost by Fenrir Greyback!\nVoldemort cast Avada Kedavra, not cool bro.\nGarrick Ollivander has been turned into a ghost by Voldemort!\nMolly Weasley cast Avada Kedavra, not cool bro.\nBellatrix Lestrange has been turned into a ghost by Molly Weasley!\nVoldemort cast Avada Kedavra, not cool bro.\nFred Weasley has been turned into a ghost by Voldemort!\nVoldemort cast Avada Kedavra, not cool bro.\n[1] \"But Harry Potter survived because he is the boy who lived!\"\n\n\n\n# Lumos!\nnames(battle_results)\n\n[1] \"battle_1\" \"battle_2\" \"battle_3\" \"battle_4\" \"battle_5\" \"battle_6\"\n\n\n\n\n\nAll good thing must come to an end, and when we are finished coding, the data often needs to leave R and go somewhere else. A highly common scenario is exporting some data out into a csv file. This is referred to as ‘writing’ the data to a csv. When working in a project, it’s good practice to have sensible subfolders for storing different types of materials. Therefore, I created an output folder to capture anything I might go on to export out of R. Here’s any example of writing the battle dataframe into a csv using write.csv() and here():\n\nwrite.csv(battles, file = here(\"output\", \"battle.csv\"))\n\n\n\nBefore we finish I thought I’d share a useful snippet for when you are left with multiple related objects (e.g., chart data for a dashboard or a set of results from the same series of analyses) and you want to write them all to the same Excel workbook with the names of the objects as the sheet names\nSpoken translation:\n\"Let's create an empty Excel workbook using the openxlsx package that i've already loaded in using library(openxlsx). For each dataframe in the list of dataframes that were created in the for loop example above, add a sheet to the empty Excel workbook with the data from that iteration written to it and with the sheet name being the same as the dataframe for the iteration we are on. Save this workbook to the output folder of this project and call the file battle_results.xlsx\".\n\n# Create a new workbook\nwb &lt;- createWorkbook()\n\n# Add each dataframe in battle_results as a separate sheet\nfor (battle_name in names(battle_results)) {\n  addWorksheet(wb, sheetName = battle_name)\n  writeData(wb, sheet = battle_name, x = battle_results[[battle_name]])\n}\n\n# Save the workbook\nsaveWorkbook(wb, here(\"output\", \"battle_results.xlsx\"), overwrite = TRUE)"
  },
  {
    "objectID": "Defence_Against_the_Dark_Arts.html#introduction",
    "href": "Defence_Against_the_Dark_Arts.html#introduction",
    "title": "Session 3: Defence Against the Dark Arts",
    "section": "",
    "text": "Word has gotten out that you are a confident coder now. With that, the data requests made of you have grown more serious, darker. We must prepare ourselves. We must learn Defence Against the Dark Arts - ways to scale up our code so that we can efficiently manage larger or more complicated tasks. In this section we are going to learn these techniques by simulating a deadly magical battle, much like the final battle in the Deathly Hallows. In order to survive we will need to acquaint ourselves with conditional logic, functions, and loops.\nIf you’ll allow a quick aside from the dark arts metaphor - a positive spin on this next step is that you are in a place where you are getting grander and more exciting ideas about how to approach analysing data and building data products. With a little bit of upfront investment in some new techniques, this process can be fun and the results more reliable, reproducible, and accessible to others, so let’s begin!\n\n# Accio libraries\nlibrary(tidyverse)\nlibrary(here)\nlibrary(glue)\nlibrary(openxlsx)\n\n# Accio data\nspells &lt;- read.csv(file = here(\"materials\", \"data\", \"spells.csv\"))\ncharacters &lt;- read.csv(file = here(\"materials\", \"data\", \"Characters.csv\"))\n\n\n\nA compulsory reminder which is relevant now more than ever is to not worry about the commas and squiggly lines, focus instead on the gist - the basic principles of what we are setting out to do and why. If you have these, then you can always seek out one of many available resources online to fill in the gaps if and when needed.\nThink of an =IF() or an =IFELSE() in Excel. The basic idea that we carry out an operation based on a condition is one of the most fundamental and powerful principles in programming. In Excel, however, it becomes quite laborious quite quickly to extend the logic within an =IF() statement to accomodate more complicated tasks and the formula quickly becomes unmanageable. This is a lot more manageable in R and after you wrap your head around it you can achieve spectacularly complex feats of data manipulation and transformation.\nThe following examples relies on data sets - one on Harry Potter characters, and the other one spells. Check them out below:\n\nstr(characters)\n\n'data.frame':   166 obs. of  9 variables:\n $ Character.ID  : int  1 2 3 4 5 6 7 8 9 10 ...\n $ Character.Name: chr  \"Harry Potter\" \"Ron Weasley\" \"Hermione Granger\" \"Albus Dumbledore\" ...\n $ Species       : chr  \"Human\" \"Human\" \"Human\" \"Human\" ...\n $ Gender        : chr  \"Male\" \"Male\" \"Female\" \"Male\" ...\n $ House         : chr  \"Gryffindor\" \"Gryffindor\" \"Gryffindor\" \"Gryffindor\" ...\n $ Patronus      : chr  \"Stag\" \"Jack Russell Terrier\" \"Otter\" \"Phoenix\" ...\n $ Wand..Wood.   : chr  \"Holly\" \"\" \"Vine\" \"Elder\" ...\n $ Wand..Core.   : chr  \"Phoenix Feather\" \"\" \"Dragon Heartstring\" \"Thestral Tail Hair\" ...\n $ student       : chr  \"y\" \"y\" \"y\" \"n\" ...\n\n\n\nstr(spells)\n\n'data.frame':   61 obs. of  5 variables:\n $ Spell.ID   : int  1 2 3 4 5 6 7 8 9 10 ...\n $ Incantation: chr  \"Accio\" \"Aguamenti\" \"Alarte Ascendare\" \"Alohomora\" ...\n $ Spell.Name : chr  \"Summoning Charm\" \"Water-Making Spell\" \"Launch an object up into the air\" \"Unlocking Charm\" ...\n $ Effect     : chr  \"Summons an object\" \"Conjures water\" \"Rockets target upward\" \"Unlocks target\" ...\n $ Light      : chr  \"\" \"Icy blue\" \"Red\" \"Blue\" ...\n\n\nThese simple dataframes (alongside having seen the films!) are perfect for practicing some conditional logic. Let’s write some code to print out the name and effect of any spell in spells. However, Hermoine is around and if we mispronounce her favourite spell or try and cast a nonsense spell, she’s going to call us out on it. Use the helper code to get the unique values of spells in the spells dataframe and try some different spells!\nSpoken translation:\n“Let's save the spell we want to apply some conditional logic too in an object called spell_cast. If the spell cast is exactly equal to Wingardium Leviosa, then print out some guidance on how to properly pronounce the spell. Apart from that exception, if the spell exists in the Incantation column of the spells dataframe then print out the spell name and the effect from the Effect column. If anything else is input other than that already accounted for print out that it is not a spell.”\n\n# unique(spells$Incantation)\n\nspell_cast &lt;- \"Immobulus\" # Change this to test different spells\n\n# Check if the spell is valid\nif (spell_cast == \"Wingardium Leviosa\") {\n  print(\"It's leviOsa, not levioSA!\")\n} else if (spell_cast %in% spells$Incantation) {\n  spell_info &lt;- spells |&gt; filter(Incantation == spell_cast)\n  print(glue(\"Spell: {spell_info$Incantation}, Effect: {spell_info$Effect}\"))\n} else {\n  print(\"Not a spell, try again.\")\n}\n\nSpell: Immobulus, Effect: Stops movement and actions of the target\n\n\n\n\n\nMy guess is that you will noticed two things after having tried out a few spells. The first is that achieving a different output by only changing one value feels very powerful. The second is that having to run all that code every time a new spell is cast gets clunky and painful. Imagine you wanted to try out 100 spells in the same script? The code would get out of hand very quickly and the resulting script would be very messy, manual, and repetitive.\nThat’s why we have functions - we wrap code that we want to run again and again with slightly different inputs into functions. The result of this is that we can stash away the code somewhere safe and out of the way and reap their benefits with very little code, typically just one line. A whole world of possibilities opens up when you start writing functions, the most immediate of which are that your code can be scaled up, shared, and tested much more effectively.\nHere is the some code as the example above wrapped in a function called spell_practice. This function takes one argument called spell_cast which allows the user to cast a spell with great ease. We say “wrapped” in a function, because all we did was take our existing code and wrap it with this:\n\nspell_practice &lt;- function(spell_cast) {\n  \n  # insert magical code here\n  \n}\n\n\n# unique(spells$Incantation)\nspell_practice &lt;- function(spell_cast) {\n  if (spell_cast == \"Wingardium Leviosa\") {\n    print(\"It's leviOsa, not levioSA!\")\n  } else if (spell_cast %in% spells$Incantation) {\n    spell_info &lt;- spells |&gt; filter(Incantation == spell_cast)\n    print(glue(\"Spell: {spell_info$Incantation}, Effect: {spell_info$Effect}\"))\n  } else {\n    print(\"Not a spell, try again.\")\n  }\n}\n\nAnd now look how easy it is to cast a spell:\n\n# unique(spells$Incantation)\nspell_practice(spell_cast = \"Expelliarmus\")\n\nSpell: Expelliarmus, Effect: Disarms an opponent\n\n\n\n# unique(spells$Incantation)\nspell_practice(spell_cast = \"Wingardium Leviosa\")\n\n[1] \"It's leviOsa, not levioSA!\"\n\n\nLet’s step it up a bit and re-enact a full magical battle. Rather than obsess over the actual contents of the battle_simulator function below, I want to try and sell to you how much time and effort was saved and how much more readable the code is now that I don’t have to copy and paste and change the code slightly to accomodate all of the multiple variations of it I might want to run. Being able to call it in only one line also makes it practical to use my function in more ambitious ways, which we’ll look at below.\nSpoken translation:\n“Let's write a magic battle simulation function with the following rules:\n1. If you cast Hermoine's favourite spell, she will correct your pronunciation.\n2. If you cast an unforgiveable spell and are a Hogwart's student you will be expelled and this will be your House status in the characters dataframe.\n3. If you cast a killing spell the character it was cast on will become a ghost in the characters dataframe.\n4. If you try and kill Harry with a spell it will not work because he is the boy who lived.\n5. The modified characters dataframe will be returned to you to ensure that the battle was carried out fairly”\n\n# unique(spells$Incantation)\n# unique(characters$Character.Name)\n\nbattle_simulator &lt;- function(character_name, spell_cast, spell_cast_to) {\n  # Unforgivable curses\n  unforgivable_curses &lt;- c(\"Avada Kedavra\", \"Crucio\", \"Imperio\")\n\n  # Initialize characters_conditionals_example_1 to the original characters dataset\n  characters_conditionals_example_1 &lt;- characters\n  modified &lt;- FALSE\n\n  # Check if the spell is valid\n  if (spell_cast == \"Wingardium Leviosa\") {\n    print(\"It's leviOsa, not levioSA!\")\n  } else if (spell_cast %in% unforgivable_curses) {\n    # If the spell is unforgivable, expel the character\n    characters_conditionals_example_1 &lt;- characters_conditionals_example_1 %&gt;%\n      mutate(House = if_else(\n        Character.Name == character_name &\n          student == \"y\" &\n          House %in% c(\"Gryffindor\", \"Slytherin\", \"Hufflepuff\", \"Ravenclaw\"),\n        \"expelled from hogwarts\",\n        House\n      ))\n\n    if (characters_conditionals_example_1 %&gt;% filter(Character.Name == character_name, student == \"y\") %&gt;% nrow() &gt; 0) {\n      print(glue(\"{character_name} has been expelled from Hogwarts for casting {spell_cast}!\"))\n      modified &lt;- TRUE\n    } else {\n      print(glue(\"{character_name} cast {spell_cast}, not cool bro.\"))\n    }\n\n    # Special case for Avada Kedavra\n    if (spell_cast == \"Avada Kedavra\") {\n      characters_conditionals_example_1 &lt;- characters_conditionals_example_1 %&gt;%\n        mutate(Species = if_else(\n          Character.Name == spell_cast_to & Character.Name != \"Harry Potter\",\n          \"ghost\",\n          Species\n        ))\n\n      if (spell_cast_to == \"Harry Potter\") {\n        print(\"But Harry Potter survived because he is the boy who lived!\")\n      } else {\n        print(glue(\"{spell_cast_to} has been turned into a ghost by {character_name}!\"))\n      }\n      modified &lt;- TRUE\n    }\n  } else if (spell_cast %in% spells$Incantation) {\n    spell_info &lt;- spells %&gt;% filter(Incantation == spell_cast)\n    print(glue(\"Spell: {spell_info$Incantation}, Effect: {spell_info$Effect}\"))\n  } else {\n    print(\"Not a spell, try again.\")\n  }\n\n  # Return the modified dataframe if changes were made, otherwise return the original characters dataframe\n  if (modified) {\n    return(characters_conditionals_example_1)\n  } else {\n    return(characters)\n  }\n}\n\n\nex1_generic &lt;- battle_simulator(\"Hermione Granger\", \"Oculus Reparo\", \"Harry Potter\")\n\nSpell: Oculus Reparo, Effect: Repairs glasses\n\n\n\nex2_wl &lt;- battle_simulator(\"Ron Weasley\", \"Wingardium Leviosa\", \"Hermione Granger\")\n\n[1] \"It's leviOsa, not levioSA!\"\n\n\n\nex3_unforgiveable_adult &lt;- battle_simulator(\"Lucius Malfoy\", \"Crucio\", \"Dobby\")\n\nLucius Malfoy cast Crucio, not cool bro.\n\n\n\nex4_unforgiveable_student &lt;- battle_simulator(\"Draco Malfoy\", \"Imperio\", \"Neville Longbottom\")\n\nDraco Malfoy has been expelled from Hogwarts for casting Imperio!\n\n\n\nex5_ghost &lt;- battle_simulator(\"Bellatrix Lestrange\", \"Avada Kedavra\", \"Sirius Black\")\n\nBellatrix Lestrange cast Avada Kedavra, not cool bro.\nSirius Black has been turned into a ghost by Bellatrix Lestrange!\n\n\n\nex6_boy_who_lived &lt;- battle_simulator(\"Voldemort\", \"Avada Kedavra\", \"Harry Potter\")\n\nVoldemort cast Avada Kedavra, not cool bro.\n[1] \"But Harry Potter survived because he is the boy who lived!\"\n\n\n\n\n\nI hope you enjoyed casting some spells and testing out some of the variations within the battle_simulator function. Why don’t you customise it, e.g., by stipulating that muggles can’t cast spells? Customising the code of others is a great way to get to grips with it and to optimise it for our individual needs.\nBut what if we had a function or set of functions that we wanted to run on an industrial scale? Even those one-liners above would get old fast if we wanted to run e.g., 1000 variations. Looping is one technique that can help here. There are some modern R-specific solutions here to simplify loops [see this article if interested](https://www.r-bloggers.com/2021/05/apply-family-in-r-apply-lapply-sapply-mapply-and-tapply/). These modern takes reduce code, but I would argue that they do so at the expense of being readable as they grow in complexity - in short the code doesn’t look like how we think about the processes they represent (in my very humble opinion). So my pitch is for good old loops, the most common of which is the for loop, which i’ll demonstrate below.\nThe core of the idea is that we have some set of entities, be it a list of string, or set of columns of rows in a dataframe, and we want to go through each iteration of that set and carry out an operation on it. Think “for each iteration of…do x”. The “i” that you will often see is a conventional placeholder. To test this, swap out each i for banana and watch the code still work). With that in mind lets simulate a battle from the Deathly Hallows (more or less) by casting lots of spells at once. To do that we need to store all of our intended steps in something. Here we are creating an object with the intention of looping through its contents, but often you won’t need to do that as your target will already exist.\n\n# Create a readable table of battles using tribble\nbattles &lt;- tribble(\n  ~caster, ~spell, ~target,\n  \"Voldemort\", \"Avada Kedavra\", \"Mad-Eye Moody\",\n  \"Fenrir Greyback\", \"Avada Kedavra\", \"Remus Lupin\",\n  \"Voldemort\", \"Avada Kedavra\", \"Garrick Ollivander\",\n  \"Molly Weasley\", \"Avada Kedavra\", \"Bellatrix Lestrange\",\n  \"Voldemort\", \"Avada Kedavra\", \"Fred Weasley\",\n  \"Voldemort\", \"Avada Kedavra\", \"Harry Potter\"\n)\n\n\n# Lumos!\nhead(battles)\n\n# A tibble: 6 × 3\n  caster          spell         target             \n  &lt;chr&gt;           &lt;chr&gt;         &lt;chr&gt;              \n1 Voldemort       Avada Kedavra Mad-Eye Moody      \n2 Fenrir Greyback Avada Kedavra Remus Lupin        \n3 Voldemort       Avada Kedavra Garrick Ollivander \n4 Molly Weasley   Avada Kedavra Bellatrix Lestrange\n5 Voldemort       Avada Kedavra Fred Weasley       \n6 Voldemort       Avada Kedavra Harry Potter       \n\n\nSpoken translation:\n“My battle_simulator function returns a dataframe, so if I'm going to run it lots at once, I'm going to need something to store them in, so let's create an empty list ahead of time before we begin. Ok let's begin. For every row in the battles dataframe, first create an name for the dataframe the battle_simulator function is about to produce. Then update my empty list with the product of my battle_simuilator function. In order to run the battle_simulator function look to the caster column to get the  character_name argument, the spell column to get the spell_cast argument, and the target column to get the spell_cast_to argument.”\n\n# Loop through battles and store results in a list\nbattle_results &lt;- list()\n\nfor (i in 1:nrow(battles)) {\n  battle_name &lt;- paste0(\"battle_\", i)\n  battle_results[[battle_name]] &lt;- battle_simulator(battles$caster[i], battles$spell[i], battles$target[i])\n}\n\nVoldemort cast Avada Kedavra, not cool bro.\nMad-Eye Moody has been turned into a ghost by Voldemort!\nFenrir Greyback cast Avada Kedavra, not cool bro.\nRemus Lupin has been turned into a ghost by Fenrir Greyback!\nVoldemort cast Avada Kedavra, not cool bro.\nGarrick Ollivander has been turned into a ghost by Voldemort!\nMolly Weasley cast Avada Kedavra, not cool bro.\nBellatrix Lestrange has been turned into a ghost by Molly Weasley!\nVoldemort cast Avada Kedavra, not cool bro.\nFred Weasley has been turned into a ghost by Voldemort!\nVoldemort cast Avada Kedavra, not cool bro.\n[1] \"But Harry Potter survived because he is the boy who lived!\"\n\n\n\n# Lumos!\nnames(battle_results)\n\n[1] \"battle_1\" \"battle_2\" \"battle_3\" \"battle_4\" \"battle_5\" \"battle_6\"\n\n\n\n\n\nAll good thing must come to an end, and when we are finished coding, the data often needs to leave R and go somewhere else. A highly common scenario is exporting some data out into a csv file. This is referred to as ‘writing’ the data to a csv. When working in a project, it’s good practice to have sensible subfolders for storing different types of materials. Therefore, I created an output folder to capture anything I might go on to export out of R. Here’s any example of writing the battle dataframe into a csv using write.csv() and here():\n\nwrite.csv(battles, file = here(\"output\", \"battle.csv\"))\n\n\n\nBefore we finish I thought I’d share a useful snippet for when you are left with multiple related objects (e.g., chart data for a dashboard or a set of results from the same series of analyses) and you want to write them all to the same Excel workbook with the names of the objects as the sheet names\nSpoken translation:\n\"Let's create an empty Excel workbook using the openxlsx package that i've already loaded in using library(openxlsx). For each dataframe in the list of dataframes that were created in the for loop example above, add a sheet to the empty Excel workbook with the data from that iteration written to it and with the sheet name being the same as the dataframe for the iteration we are on. Save this workbook to the output folder of this project and call the file battle_results.xlsx\".\n\n# Create a new workbook\nwb &lt;- createWorkbook()\n\n# Add each dataframe in battle_results as a separate sheet\nfor (battle_name in names(battle_results)) {\n  addWorksheet(wb, sheetName = battle_name)\n  writeData(wb, sheet = battle_name, x = battle_results[[battle_name]])\n}\n\n# Save the workbook\nsaveWorkbook(wb, here(\"output\", \"battle_results.xlsx\"), overwrite = TRUE)"
  },
  {
    "objectID": "Defence_Against_the_Dark_Arts.html#recap",
    "href": "Defence_Against_the_Dark_Arts.html#recap",
    "title": "Session 3: Defence Against the Dark Arts",
    "section": "Recap",
    "text": "Recap\n\n\nBigger and bolder ideas require better tools.\nConditional logic, functions and loops unlock a world of efficient, accessible, and reproducible code.\nAs always, don’t worry about the commas and squiggly lines and take one step at a time."
  },
  {
    "objectID": "Sorting.html",
    "href": "Sorting.html",
    "title": "Session 1: Sorting",
    "section": "",
    "text": "Hello everyone, you are probably interested in this bootcamp because you are pretty nifty with a spreadsheet already, but are getting fed up of seeing R users driving around Wakefield and beyond in their Lamborghini’s and Ferrari’s and you have thought - enough is enough, I want a piece of the pie. I want the glamorous life of an R programmer. Well look no further, in these three sessions we, the City and Guilds R development community, will equip you with everything you need to begin your new, more prosperous life.\nConsuming information is easier if\n\nIt’s fun, which is why we’ll be working with publicly available data sets relating to the Harry Potter universe throughout, and;\nIt’s done actively, which is why you will coding along - this is a non-negotiable.\n\n\n\nMany people find coding enjoyable, others not so much. But this isn’t why data analysts, software developers, data scientists and the like do it. The real reason is because it both extends our capabilities and saves time simulaneously, in essence the juice is worth the squeeze. At some point the spreadsheets become too big, the tasks become too repetitive, the maintenance of products become too laborious. Remember when Harry, Hermoine, and Ron had to leave the comfort of the castle to go and hunt down the horcruxes? It’s kind of like that, except admittedly not as dramatic.\n\n\nQ: Do I need to be good at maths to code?\nA: Nope, very little/no mathematics involved in most day-to-day tasks.\nQ: What is a programming language?\nA: When we are coding we are essentially having a conversation with our machine and asking it to do things for us. These conversations are difficult because computers will only communicate is very specific ways, they are extremely fussy. A programming language is a set of established rules and conventions through which we can communicate with our machines.\nQ: Is there more than one programming language?\nA: Yes, there are many. Languages are typically created or adapted for specific purposes. For example, R, the one you are most likely to have heard of, is known as a statistical programming language. This just means it was made by stats geeks working in universities and has been refined by this community for many years to the point now where it is arguably the best language to carry out data analytics/ statistics/ data visualisation. If you were building a website however, you might use Javascript, or if you were developing a game you might use something like C++,. if you were storing large amounts of information in a database you’d probably use SQL, and so on and so forth. Python, another language you might have of, is a bit unusual, in that its more of a general purpose language. Someone (I can’t remember who) once said that Python is the second best language for everything, meaning that it’s also an excellent choice if you were only to learn one language, as you can apply it to most tasks.\nQ: \"I must not be good at this, it keeps breaking\"\nA: Errors are a day-to-day part of the process! Computers are very unreasonable things to communicate with and they will tell you about every tiny little thing you did wrong. This is good, errors give us the clues we need to get our script running!\nQ: Do I need to memorise lots of things to be a good coder?\nA: Ultimately everyone finds their own way, but i’d argue no, not at all. For most people, coding is a practical rather than theoretical discipline. Getting stuck in is the best way to learn, we sort of are a product of the problems we have solved, not the things we have learned. That doesn’t mean that you won’t naturally start to remember where the commas and the curly brackets go after a while, but this is not the point or the goal. It would be inefficient (and near impossible) to memorise all of the rules, functions, and tools out there. Instead, each time you solve a problem using code, you get more resilient to errors, more knowledgeable about where and how to access the resources you need to solve just about any problem on the fly, and you generally just become more and more confident that whatever comes up, you’ll be able to figure it out."
  },
  {
    "objectID": "Sorting.html#introduction",
    "href": "Sorting.html#introduction",
    "title": "Session 1: Sorting",
    "section": "",
    "text": "Hello everyone, you are probably interested in this bootcamp because you are pretty nifty with a spreadsheet already, but are getting fed up of seeing R users driving around Wakefield and beyond in their Lamborghini’s and Ferrari’s and you have thought - enough is enough, I want a piece of the pie. I want the glamorous life of an R programmer. Well look no further, in these three sessions we, the City and Guilds R development community, will equip you with everything you need to begin your new, more prosperous life.\nConsuming information is easier if\n\nIt’s fun, which is why we’ll be working with publicly available data sets relating to the Harry Potter universe throughout, and;\nIt’s done actively, which is why you will coding along - this is a non-negotiable.\n\n\n\nMany people find coding enjoyable, others not so much. But this isn’t why data analysts, software developers, data scientists and the like do it. The real reason is because it both extends our capabilities and saves time simulaneously, in essence the juice is worth the squeeze. At some point the spreadsheets become too big, the tasks become too repetitive, the maintenance of products become too laborious. Remember when Harry, Hermoine, and Ron had to leave the comfort of the castle to go and hunt down the horcruxes? It’s kind of like that, except admittedly not as dramatic.\n\n\nQ: Do I need to be good at maths to code?\nA: Nope, very little/no mathematics involved in most day-to-day tasks.\nQ: What is a programming language?\nA: When we are coding we are essentially having a conversation with our machine and asking it to do things for us. These conversations are difficult because computers will only communicate is very specific ways, they are extremely fussy. A programming language is a set of established rules and conventions through which we can communicate with our machines.\nQ: Is there more than one programming language?\nA: Yes, there are many. Languages are typically created or adapted for specific purposes. For example, R, the one you are most likely to have heard of, is known as a statistical programming language. This just means it was made by stats geeks working in universities and has been refined by this community for many years to the point now where it is arguably the best language to carry out data analytics/ statistics/ data visualisation. If you were building a website however, you might use Javascript, or if you were developing a game you might use something like C++,. if you were storing large amounts of information in a database you’d probably use SQL, and so on and so forth. Python, another language you might have of, is a bit unusual, in that its more of a general purpose language. Someone (I can’t remember who) once said that Python is the second best language for everything, meaning that it’s also an excellent choice if you were only to learn one language, as you can apply it to most tasks.\nQ: \"I must not be good at this, it keeps breaking\"\nA: Errors are a day-to-day part of the process! Computers are very unreasonable things to communicate with and they will tell you about every tiny little thing you did wrong. This is good, errors give us the clues we need to get our script running!\nQ: Do I need to memorise lots of things to be a good coder?\nA: Ultimately everyone finds their own way, but i’d argue no, not at all. For most people, coding is a practical rather than theoretical discipline. Getting stuck in is the best way to learn, we sort of are a product of the problems we have solved, not the things we have learned. That doesn’t mean that you won’t naturally start to remember where the commas and the curly brackets go after a while, but this is not the point or the goal. It would be inefficient (and near impossible) to memorise all of the rules, functions, and tools out there. Instead, each time you solve a problem using code, you get more resilient to errors, more knowledgeable about where and how to access the resources you need to solve just about any problem on the fly, and you generally just become more and more confident that whatever comes up, you’ll be able to figure it out."
  },
  {
    "objectID": "Sorting.html#the-sorting-hat-of-programming-languages",
    "href": "Sorting.html#the-sorting-hat-of-programming-languages",
    "title": "Session 1: Sorting",
    "section": "The sorting hat of programming languages ",
    "text": "The sorting hat of programming languages \nThe sorting hat is about to choose your first language are you ready?\n“You want to transform, analyse, and visualise data I see? Hmmmmm... you'll need a language with lots of resources and community support for these tasks. Your organisation already has lots of products and staff trained around a language that does this already? Hmmm....in that case then.....let's start learning.....R!“"
  },
  {
    "objectID": "Sorting.html#your-first-day-at-hogwarts",
    "href": "Sorting.html#your-first-day-at-hogwarts",
    "title": "Session 1: Sorting",
    "section": "Your first day at Hogwarts",
    "text": "Your first day at Hogwarts\nImagine it’s your first day at Hogwarts, what do you think you’d prioritize first? Fighting a troll? Entering the Triwizard Cup? Hunting down He Shall Not be Named? Nah, you are probably going to want to figure out where your dorms are, what time dinner is at, and how much a pint of butter beer is. It’s no different in R - becoming comfortable with our surroundings is essential to producing good work.\n\nWhat is RStudio?\nRStudio is what is called an Interactive Development Environment, or IDE. So R is how we are going to communicate with our computers, RStudio is where we are going to have the chat. RStudio is not the only place we can have that chat (e.g., see Positron), but for now it’s a great place and the only one you need consider. In fact, why don’t you pin it to your task bar now!\n\n\nWhat is a project?\nOnce you open up RStudio can can start coding straight off the bat. However, a better idea is to learn about RStudio projects, luckily it only takes a minutes, let’s go. Let’s say you are going to start a three month piece of work that will use R to analyse exam results, then you would typically do that in a dedicated place. The place for that is within an R project environment. This would be different from a separate R project we created to analyse student feedback surveys. Apart from just being an organised approach, creating R projects comes with many benefits. The one I’m going to sell to you to encourage you to use R projects is this: if you don’t use R projects you’ll need to tell it where files lives by using their exact location (or path), and these are gross, for example this is where the data for this project lives on my machine: \"C:\\Users\\TomHun\\OneDrive - City & Guilds\\Documents\\Code\\R\\harry_potteR_bootcamp\\materials\\data\" - yuck!\nInstead, however, since I’m working in an R project called coffee_and_code, R sets this folder as the centre of the universe and makes a lot of that awful path business fairly automatic. The project dialogue box lives on the top right of your RStudio, the rest is self-explanatory once you click it and click New Project:\n\n\n\n\n\n\n\nWhat is a script?\nThere’s two places you can write code in R Studio. You have a console (look down the bottom), and you have a script window, which is the main body of the RStudio environment. So why confuse things by letting me write code in more than one place? Well, the reason for this, at least how I look at it, is that the script window is for where you want to write a shopping list of code, maybe even as much as hundreds or thousands of lines, that you want to be able to run in that order, whenever you want. The console is where you might want to run lots of bitty or diagnostic lines of code that give you the info you need to write that script, e.g., to see the top 5 lines of a data frame, or to see which version of R you are running etc. Here’s how to open a new script:\n\n\n\nWhat is Quarto?\nIf a script is just the place that you write your shopping list, then a Quarto document is just a fancy script. You don’t have to do your coding in Quarto, but after trying it you’ll probably want to. That’s because it has many bells and whistles attached that make writing a script pleasant. These include: (1) being able have really polished notes or description sections that has a lot of the same functionality as MS Word; (2) being able to view the results of your code in a neat way whenever you want as you write your code; (3) you can even publish your results as nicely formatted webpages or even books. If you don’t have the bandwidth for that now that’s totally fine, just store Quarto documents away as “just fancy scripts”.\n\nWhat is a chunk?\nAs discussed above, Quarto documents give us nice dedicated places to write our code, called chunks. Scripts are fine and all, but they are a bit of a free-for-all, anything can go anywhere. This might be what you are after, but if not then Quarto offers a nice tidy experience with dedicated chunks for code. Here’s where you go to create a new chunk:\n\nand here’s what one looks like:\n\nprint(\"Hello world!\")\n\n[1] \"Hello world!\"\n\n\n\n\n\nWhat is a library?\nGreat news, set up is almost complete! All that’s needed beforehand is a quick chat about libraries. Remember earlier when I said that coding is like having a conversation with a machine? Well some conversations have been so important and/or difficult to have that others have went to the trouble of saving them for us. They centre around a relatively specific purpose, e.g., anything from visualising data to editing photos. Let’s use a silly example to illustrate the point. Someone, somewhere, for some reason went to the trouble of creating a package that allows us to add emojis to our plots. They thought (correctly) that I might also want emojis on my plots. So they created a package giving me everything I needed to ask my machine to add the emojis. All I need to do is install the package, and load in the library for it. Let’s go, I’m going to write the code that installs the package into my console (preference, and I only need to run it once):\n\n\n# Accio emojifont!\nlibrary(emojifont)\n\n# Accio plot!\nset.seed(200)\nx &lt;- rnorm(10)\nset.seed(100)\ny &lt;- rnorm(10)\nplot(x, y, cex = 0)\ntext(x, y, labels=emoji('joy'), cex=8, col='black',\n    family='EmojiOne')\n\n\n\n\n\n\n\n\nThe point? There are a lot of clever people out there having difficult conversations with their machines and making their achievements available to us in a very accessible way. We of course don’t need to remember all of these or research them, instead we’ll pick them up as we go along and remember some naturally if we keep going back to them. The exception to this is the \"tidyverse\", a super famous collection of packages which makes working with data in R so much easier. You’ll pretty much always be using this, so let’s load it in (as aside here is that if you see “#” at the start of a line in a chunk, then that line is commented out, i.e., it’s not live code, it’s just a note):\n\n# install.packages(\"tidyverse\") if not already installed\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "Sorting.html#reading-in-data",
    "href": "Sorting.html#reading-in-data",
    "title": "Session 1: Sorting",
    "section": "Reading in data",
    "text": "Reading in data\nIf you want to work with data in R you’ll either need to create it or “read it in”, so let’s read in some Harry potter data. Many types of data can be read into R (e.g., Excel files, Google Sheets, SPSS files etc), but csv files are by far the most common. For those unaware, csvs are like stripped down Excel files that work nicely in R, so you’ll be using these a lot.\nWhat you need to know before looking at the code below is that I’m working in an R project called “coffee_and_code”. My RStudio now thinks that the coffee_and_code folder on my machine is the centre of the universe. That means that any other file locations on my machine are relative to it. As such, I have a sub-folder in my project called “harry_potter_files”. So let’s do the following things:\n\nCreate an object and let’s call it “movies”\nWhat we want the object “movies” to be is everything to the right of “&lt;-”\nWhat we want movies to be then is the product of reading in the spreadsheet movies.csv from the folder harry_potter_files which exists inside my R project.\n\nAltogether that looks like this:\n\nmovies &lt;- read.csv(file = \"materials/data/movies.csv\")\n\nOR, a cleaner way of doing it (especially with many sub-folders inside a project) is by using the here package, which does a nice job of getting rid of all the slashes and other intimidating path-related stuff:\n\n# install.packages(\"here\") if not installed already\nlibrary(here)\n\nhere() starts at C:/Users/TomHun/OneDrive - City & Guilds/Documents/Code/R/harry_potteR_bootcamp\n\nmovies &lt;- read.csv(file = here(\"materials\", \"data\",\"movies.csv\"))"
  },
  {
    "objectID": "Sorting.html#lumos-code-to-help-see-in-the-dark",
    "href": "Sorting.html#lumos-code-to-help-see-in-the-dark",
    "title": "Session 1: Sorting",
    "section": "Lumos! Code to help see in the dark",
    "text": "Lumos! Code to help see in the dark\n\nExcellent work, the set-up is now over - we have some data now let’s start exploring it! But wait - where is it?\nOne of the hardest obstacles for those switching over from Excel is that they can no longer see their data, and that’s a bit weird and off-putting and takes a little bit of getting used to. It’s a very worthwhile trade-off though as we can now work with sheets millions of rows long without it crashing. Let’s now switch to a strategy I’ve called Lumos above which is the Harry Potter spell for creating light. What we are going to do is cast light on the parts of our data that we need to see in that given moment. We accept that our data set is often way too big to just have open in front us, so instead we cast our wands on the bits we need. One would typically run these as-and-when-needed in your console to assist writing your main script in your script window, but let’s just pop them in chunks below for demonstrative purposes.\nSo what do know so far? We know that we have some data loaded in from a spreadsheet called movies.csv, and it has something to do with Harry Potter. Let’s find out some more things about it:\n\n# What are the names of the columns?\nnames(movies)\n\n[1] \"Movie.ID\"     \"Movie.Title\"  \"Release.Year\" \"Runtime\"      \"Budget\"      \n[6] \"Box.Office\"  \n\n\n\n# What do the first few rows look like?\nhead(movies)\n\n  Movie.ID                               Movie.Title Release.Year Runtime\n1        1  Harry Potter and the Philosopher's Stone         2001     152\n2        2   Harry Potter and the Chamber of Secrets         2002     161\n3        3  Harry Potter and the Prisoner of Azkaban         2004     142\n4        4       Harry Potter and the Goblet of Fire         2005     157\n5        5 Harry Potter and the Order of the Phoenix         2007     138\n6        6    Harry Potter and the Half-Blood Prince         2009     153\n     Budget Box.Office\n1 125000000 1002000000\n2 100000000  880300000\n3 130000000  796700000\n4 150000000  896400000\n5 150000000  942000000\n6 250000000  943200000\n\n\n\n# What unique values are there in the Movie.Title column?\nunique(movies$Movie.Title)\n\n[1] \"Harry Potter and the Philosopher's Stone\"   \n[2] \"Harry Potter and the Chamber of Secrets\"    \n[3] \"Harry Potter and the Prisoner of Azkaban\"   \n[4] \"Harry Potter and the Goblet of Fire\"        \n[5] \"Harry Potter and the Order of the Phoenix\"  \n[6] \"Harry Potter and the Half-Blood Prince\"     \n[7] \"Harry Potter and the Deathly Hallows Part 1\"\n[8] \"Harry Potter and the Deathly Hallows Part 2\"\n\n\n\n# What is the overall structure of the data?\nstr(movies)\n\n'data.frame':   8 obs. of  6 variables:\n $ Movie.ID    : int  1 2 3 4 5 6 7 8\n $ Movie.Title : chr  \"Harry Potter and the Philosopher's Stone\" \"Harry Potter and the Chamber of Secrets\" \"Harry Potter and the Prisoner of Azkaban\" \"Harry Potter and the Goblet of Fire\" ...\n $ Release.Year: int  2001 2002 2004 2005 2007 2009 2010 2011\n $ Runtime     : int  152 161 142 157 138 153 146 130\n $ Budget      : int  125000000 100000000 130000000 150000000 150000000 250000000 200000000 250000000\n $ Box.Office  : int  1002000000 880300000 796700000 896400000 942000000 943200000 976900000 1342000000\n\n\n\nRecap\n\n\nLet’s learn to code to make our lives easier, not more difficult.\nLet’s do it in R because it’s specialized in working with data, and because a community of practice is being built around it at City and Guilds. This means we can reap the benefits of a consistent approach and support each other.\nLet’s use RStudio and within project environments, because file paths are annoying and scary.\nLet’s use the tidyverse, because it’s the best package ever.\nWe can ready in just about any data we want to, but most of the time that will mean working with csvs.\nNot having a spreadsheet open in front of us is fine, because we can now see in the dark."
  }
]